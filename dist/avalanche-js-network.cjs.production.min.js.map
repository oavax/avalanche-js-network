{"version":3,"file":"avalanche-js-network.cjs.production.min.js","sources":["../src/types.ts","../src/providers/baseSocket.ts","../src/providers/baseProvider.ts","../src/providers/defaultFetcher.ts","../src/rpcMethod/net.ts","../src/providers/http.ts","../src/providers/provider.ts","../src/rpcMethod/builder.ts","../src/providers/ws.ts","../src/providers/emitter.ts","../src/rpcMethod/rpc.ts","../src/messenger/responseMiddleware.ts","../src/messenger/messenger.ts","../src/tracker/baseTracker.ts","../src/tracker/pollingTracker.ts","../src/tracker/subscribeTracker.ts","../src/subscriptions/Subscription.ts","../src/subscriptions/LogSub.ts","../src/subscriptions/NewHeadersSub.ts","../src/subscriptions/NewPendingTransactionsSub.ts","../src/subscriptions/SyncingSub.ts","../src/util.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module avalanche-network\n * @ignore\n */\n\nimport { RPCMethod, RPCErrorCode } from './rpcMethod/rpc';\n\nexport type ReqMiddleware = Map<string | RPCMethod | RegExp, any[]>;\nexport type ResMiddleware = Map<string | RPCMethod | RegExp, any[]>;\n\nexport enum MiddlewareType {\n  REQ,\n  RES,\n}\n\nexport enum SubscribeReturns {\n  all = 'all',\n  id = 'id',\n  method = 'method',\n}\n\nexport interface Middleware {\n  request: object;\n  response: object;\n}\n\nexport interface RPCRequestPayload<T> {\n  id: number;\n  jsonrpc: string;\n  method: RPCMethod | string;\n  params: T;\n}\n\nexport interface RPCRequestOptions {\n  headers: [];\n  method: string;\n}\n\nexport interface RPCRequest<T> {\n  url: string;\n  payload: RPCRequestPayload<T>;\n  options: RPCRequestOptions;\n}\n\nexport interface RPCResponseBase {\n  jsonrpc: string;\n  id: string;\n}\n\nexport interface RPCResponseBody<R, E> extends RPCResponseBase {\n  result: R;\n  error: E;\n}\n\nexport interface RPCError {\n  code: RPCErrorCode;\n  message: string;\n  data: any;\n}\n\nexport interface RPCResult {\n  resultString: string;\n  resultMap: Map<string, any>;\n  resultList: any[];\n  raw: any;\n}\n\nexport interface ShardingItem {\n  current: boolean;\n  shardID: number | string;\n  http: string;\n  ws: string;\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { isWs } from 'avalanche-js-utils';\nimport mitt from 'mitt';\nimport { BaseProvider } from './baseProvider';\n\nexport enum SocketConnection {\n  READY = 'ready',\n  CONNECT = 'connect',\n  ERROR = 'error',\n  CLOSE = 'close',\n}\n\nexport enum SocketState {\n  SOCKET_MESSAGE = 'socket_message',\n  SOCKET_READY = 'socket_ready',\n  SOCKET_CLOSE = 'socket_close',\n  SOCKET_ERROR = 'socket_error',\n  SOCKET_CONNECT = 'socket_connect',\n  SOCKET_NETWORK_CHANGED = 'socket_networkChanged',\n  SOCKET_ACCOUNTS_CHANGED = 'socket_accountsChanged',\n}\n\nexport enum EmittType {\n  INSTANCE = 'instance',\n  PUBSUB = 'pubsub',\n}\n\nclass BaseSocket extends BaseProvider {\n  url: string;\n  emitter: mitt.Emitter;\n  handlers: any = {};\n  constructor(url: string) {\n    super(url);\n    if (!isWs(url)) {\n      throw new Error(`${url} is not websocket`);\n    }\n    this.url = url;\n    this.emitter = mitt(this.handlers);\n  }\n  resetHandlers() {\n    // tslint:disable-next-line: forin\n    for (const i in this.handlers) {\n      delete this.handlers[i];\n    }\n  }\n\n  once(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, handler);\n    this.removeEventListener(type);\n  }\n\n  addEventListener(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, handler);\n  }\n\n  removeEventListener(type?: string, handler?: mitt.Handler) {\n    if (!type) {\n      this.handlers = {};\n      return;\n    }\n    if (!handler) {\n      delete this.handlers[type];\n    } else {\n      return this.emitter.off(type, handler);\n    }\n  }\n  reset() {\n    this.removeEventListener('*');\n    // this.registerEventListeners();\n  }\n  removeAllSocketListeners() {\n    this.removeEventListener(SocketState.SOCKET_MESSAGE);\n    this.removeEventListener(SocketState.SOCKET_READY);\n    this.removeEventListener(SocketState.SOCKET_CLOSE);\n    this.removeEventListener(SocketState.SOCKET_ERROR);\n    this.removeEventListener(SocketState.SOCKET_CONNECT);\n  }\n\n  onReady(event: any) {\n    this.emitter.emit(SocketConnection.READY, event);\n    this.emitter.emit(SocketState.SOCKET_READY, event);\n  }\n  onError(error: any) {\n    this.emitter.emit(SocketConnection.ERROR, error);\n    this.emitter.emit(SocketState.SOCKET_ERROR, error);\n    this.removeAllSocketListeners();\n    this.removeEventListener('*');\n  }\n  onClose(error = null) {\n    this.emitter.emit(SocketConnection.CLOSE, error);\n    this.emitter.emit(SocketState.SOCKET_CLOSE, error);\n    this.removeAllSocketListeners();\n    this.removeEventListener('*');\n  }\n}\n\nexport { BaseSocket };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { ReqMiddleware, ResMiddleware, MiddlewareType } from '../types';\nimport { RPCMethod } from '../rpcMethod/rpc';\n\nclass BaseProvider {\n  middlewares = {\n    request: {\n      use: (fn: ReqMiddleware, match: string | RPCMethod | RegExp = '*') => {\n        this.pushMiddleware(fn, MiddlewareType.REQ, match);\n      },\n    },\n    response: {\n      use: (fn: ResMiddleware, match: string | RPCMethod | RegExp = '*') => {\n        this.pushMiddleware(fn, MiddlewareType.RES, match);\n      },\n    },\n  };\n  protected url: string;\n  protected reqMiddleware: ReqMiddleware = new Map().set('*', []);\n  protected resMiddleware: ResMiddleware = new Map().set('*', []);\n\n  constructor(\n    url: string,\n    reqMiddleware: ReqMiddleware = new Map(),\n    resMiddleware: ResMiddleware = new Map(),\n  ) {\n    this.reqMiddleware = reqMiddleware;\n    this.resMiddleware = resMiddleware;\n    this.url = url;\n  }\n\n  protected pushMiddleware(fn: any, type: MiddlewareType, match: string | RPCMethod | RegExp) {\n    if (type !== MiddlewareType.REQ && type !== MiddlewareType.RES) {\n      throw new Error('Please specify the type of middleware being added');\n    }\n    if (type === MiddlewareType.REQ) {\n      const current = this.reqMiddleware.get(match) || [];\n      this.reqMiddleware.set(match, [...current, <ReqMiddleware>fn]);\n    } else {\n      const current = this.resMiddleware.get(match) || [];\n      this.resMiddleware.set(match, [...current, <ResMiddleware>fn]);\n    }\n  }\n  protected getMiddleware(method: RPCMethod | string): [ReqMiddleware[], ResMiddleware[]] {\n    const requests: ReqMiddleware[] = [];\n    const responses: ResMiddleware[] = [];\n\n    for (const [key, transformers] of this.reqMiddleware.entries()) {\n      if (typeof key === 'string' && key !== '*' && key === method) {\n        requests.push(...transformers);\n      }\n\n      if (key instanceof RegExp && key.test(method)) {\n        requests.push(...transformers);\n      }\n\n      if (key === '*') {\n        requests.push(...transformers);\n      }\n    }\n\n    for (const [key, transformers] of this.resMiddleware.entries()) {\n      if (typeof key === 'string' && key !== '*' && key === method) {\n        responses.push(...transformers);\n      }\n\n      if (key instanceof RegExp && key.test(method)) {\n        responses.push(...transformers);\n      }\n\n      if (key === '*') {\n        responses.push(...transformers);\n      }\n    }\n\n    return [requests, responses];\n  }\n}\n\nexport { BaseProvider };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport fetch from 'cross-fetch';\nimport { RPCRequest, RPCResponseBody, RPCError, RPCResult } from '../types';\n\nexport const fetchRPC = {\n  requestHandler: (request: RPCRequest<any[]>, headers: any) =>\n    fetch(request.url, {\n      method: request.options && request.options.method ? request.options.method : 'POST',\n      cache: 'no-cache',\n      mode: 'cors',\n      redirect: 'follow',\n      referrer: 'no-referrer',\n      body: JSON.stringify(request.payload),\n      headers: {\n        ...headers,\n        ...(request.options && request.options.headers ? request.options.headers : {}),\n      },\n    }),\n  responseHandler: (response: Response, request: RPCRequest<any>, handler: any) =>\n    response\n      .json()\n      .then((body: RPCResponseBody<RPCResult, RPCError>) => {\n        return { ...body, req: request };\n      })\n      .then(handler),\n};\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @ignore\n */\n\nexport const DEFAULT_TIMEOUT: number = 120000;\n\nexport const DEFAULT_HEADERS: object = { 'Content-Type': 'application/json' };\n\nfunction _fetch(fetchPromise: Promise<any>, timeout: number) {\n  let abortFn: () => void;\n\n  const abortPromise = new Promise((resolve, reject) => {\n    abortFn = () => reject(new Error(`request Timeout in ${timeout} ms`));\n  });\n  const abortablePromise = Promise.race([fetchPromise, abortPromise]);\n\n  setTimeout(() => {\n    abortFn();\n  }, timeout);\n\n  return abortablePromise;\n}\n\nexport const performRPC = async (request: any, handler: any, fetcher: any) => {\n  try {\n    const response = await _fetch(\n      fetcher.requestHandler(request, DEFAULT_HEADERS),\n      request.options && request.options.timeout ? request.options.timeout : DEFAULT_TIMEOUT,\n    );\n    return fetcher.responseHandler(response, request, handler);\n  } catch (err) {\n    throw err;\n  }\n};\n\nexport function composeMiddleware(...fns: any[]): any {\n  if (fns.length === 0) {\n    return (arg: any) => arg;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return fns.reduce((a, b) => (arg: any) => a(b(arg)));\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { BaseProvider } from './baseProvider';\nimport { fetchRPC } from './defaultFetcher';\nimport { composeMiddleware, performRPC, DEFAULT_TIMEOUT, DEFAULT_HEADERS } from '../rpcMethod/net';\n\nimport { RPCRequestPayload } from '../types';\n\n/** @hidden */\nconst defaultOptions = {\n  method: 'POST',\n  timeout: DEFAULT_TIMEOUT,\n  headers: DEFAULT_HEADERS,\n  user: null,\n  password: null,\n};\n\nclass HttpProvider extends BaseProvider {\n  url: string;\n  fetcher?: any;\n  options?: any;\n  constructor(url: string, options?: any, fetcher?: any) {\n    super(url);\n    this.url = url || 'http://localhost:9500';\n    this.fetcher = fetcher || fetchRPC;\n    if (options) {\n      this.options = {\n        method: options.method || defaultOptions.method,\n        timeout: options.timeout || defaultOptions.timeout,\n        user: options.user || defaultOptions.user,\n        password: options.password || defaultOptions.password,\n        headers: options.headers || defaultOptions.headers,\n      };\n    } else {\n      this.options = defaultOptions;\n    }\n  }\n\n  /**\n   * @function send\n   * @memberof HttpProvider.prototype\n   * @param  {Object} payload  - payload object\n   * @param  {Function} callback - callback function\n   * @return {any} - RPC Response\n   */\n  send(payload: RPCRequestPayload<object>, callback?: any): Promise<any> {\n    return this.requestFunc({ payload, callback });\n  }\n\n  /**\n   * @function sendServer\n   * @memberof HttpProvider.prototype\n   * @param  {String} endpoint - endpoint to server\n   * @param  {Object} payload  - payload object\n   * @param  {Function} callback - callback function\n   * @return {Function} - RPC Response\n   */\n  sendServer(endpoint: string, payload: RPCRequestPayload<object>, callback: any): Promise<any> {\n    return this.requestFunc({ endpoint, payload, callback });\n  }\n\n  requestFunc({\n    endpoint,\n    payload,\n    callback,\n  }: {\n    endpoint?: string;\n    payload: RPCRequestPayload<object>;\n    callback?: any;\n  }): Promise<any> {\n    const [tReq, tRes] = this.getMiddleware(payload.method);\n    const reqMiddleware = composeMiddleware(\n      ...tReq,\n      (obj: object) => this.optionsHandler(obj),\n      (obj: object) => this.endpointHandler(obj, endpoint),\n      this.payloadHandler,\n    );\n    const resMiddleware = composeMiddleware(\n      (data: object) => this.callbackHandler(data, callback),\n      ...tRes,\n    );\n\n    const req = reqMiddleware(payload);\n\n    return performRPC(req, resMiddleware, this.fetcher);\n  }\n\n  /**\n   * @function payloadHandler\n   * @memberof HttpProvider.prototype\n   * @param  {Object} payload - payload object\n   * @return {Object} - to payload object\n   */\n  payloadHandler(payload: RPCRequestPayload<object>): object {\n    return { payload };\n  }\n\n  /**\n   * @function endpointHandler\n   * @memberof HttpProvider.prototype\n   * @param  {Object} obj      - payload object\n   * @param  {String} endpoint - add the endpoint to payload object\n   * @return {Object} - assign a new object\n   */\n  endpointHandler(obj: object, endpoint?: string): object {\n    return {\n      ...obj,\n      url: endpoint !== null && endpoint !== undefined ? `${this.url}${endpoint}` : this.url,\n    };\n  }\n\n  /**\n   * @function optionsHandler\n   * @memberof HttpProvider.prototype\n   * @param  {object} obj - options object\n   * @return {object} - assign a new option object\n   */\n  optionsHandler(obj: object): object {\n    if (this.options.user && this.options.password) {\n      const AUTH_TOKEN = `Basic ${Buffer.from(\n        `${this.options.user}:${this.options.password}`,\n      ).toString('base64')}`;\n      this.options.headers.Authorization = AUTH_TOKEN;\n    }\n\n    return { ...obj, options: this.options };\n  }\n\n  /**\n   * @function callbackHandler\n   * @memberof HttpProvider.prototype\n   * @param  {Object} data - from server\n   * @param  {Function} cb   - callback function\n   * @return {Object|Function} - return object or callback function\n   */\n  callbackHandler(data: any, cb: any): any {\n    if (cb) {\n      cb(null, data);\n    }\n    return data;\n  }\n\n  subscribe() {\n    throw new Error('HTTPProvider does not support subscriptions.');\n  }\n\n  unsubscribe() {\n    throw new Error('HTTPProvider does not support subscriptions.');\n  }\n}\n\nexport { HttpProvider };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { HttpProvider } from './http';\nimport { WSProvider } from './ws';\nimport { defaultConfig, isHttp, isWs } from 'avalanche-js-utils';\n\nexport enum ProviderType {\n  http = 'http',\n  ws = 'ws',\n}\n\nexport class Provider {\n  static getProvider(provider: string | HttpProvider | WSProvider) {\n    try {\n      this.getProvider(provider);\n      return new Provider(provider);\n    } catch (error) {\n      throw error;\n    }\n  }\n  public provider: WSProvider | HttpProvider;\n  public providerType: ProviderType;\n  constructor(url: string | WSProvider | HttpProvider) {\n    this.provider = this.onInitSetProvider(url);\n    this.providerType = this.getType(this.provider);\n  }\n  private onInitSetProvider(\n    providerUrl: string | HttpProvider | WSProvider,\n  ): HttpProvider | WSProvider {\n    if (typeof providerUrl === 'string') {\n      return isHttp(providerUrl)\n        ? new HttpProvider(providerUrl)\n        : isWs(providerUrl)\n        ? new WSProvider(providerUrl)\n        : new HttpProvider(defaultConfig.Default.Chain_URL);\n    }\n    try {\n      const providerType = this.getType(providerUrl);\n      if (providerType === ProviderType.http || providerType === ProviderType.ws) {\n        return providerUrl;\n      } else {\n        throw new Error('cannot get provider type');\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  private getType(provider: HttpProvider | WSProvider) {\n    if (provider instanceof HttpProvider) {\n      return ProviderType.http;\n    }\n    if (provider instanceof WSProvider) {\n      return ProviderType.ws;\n    }\n    throw new Error('provider is not correct');\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { RPCRequestPayload } from '../types';\nimport { RPCMethod } from './rpc';\n/**\n * @class JsonRpc\n * @description json rpc instance\n * @return {JsonRpc} Json RPC instance\n */\nclass JsonRpc {\n  messageId: number;\n  constructor() {\n    /**\n     * @var {Number} messageId\n     * @memberof JsonRpc.prototype\n     * @description message id, default 0\n     */\n    this.messageId = 0;\n  }\n\n  /**\n   * @function toPayload\n   * @memberof JsonRpc.prototype\n   * @description convert method and params to payload object\n   * @param  {String} method - RPC method\n   * @param  {Array<object>} params - params that send to RPC\n   * @return {Object} payload object\n   */\n  toPayload = (\n    method: RPCMethod | string,\n    params: string | undefined | any[],\n  ): RPCRequestPayload<any> => {\n    // FIXME: error to be done by shared/errors\n    if (!method) {\n      throw new Error('jsonrpc method should be specified!');\n    }\n\n    // advance message ID\n    this.messageId += 1;\n\n    const sendParams =\n      params === undefined ? [] : typeof params === 'string' ? [params] : [...params];\n\n    return {\n      jsonrpc: '2.0',\n      id: this.messageId,\n      method,\n      params: sendParams,\n    };\n  };\n}\n\nexport { JsonRpc };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\n// TODO: implement Websocket Provider\nimport { w3cwebsocket as W3CWebsocket } from 'websocket';\nimport {\n  BaseSocket,\n  SocketConnection,\n  SocketState,\n  // EmittType,\n} from './baseSocket';\nimport { isWs, isObject, isArray } from 'avalanche-js-utils';\nimport { JsonRpc } from '../rpcMethod/builder';\nimport { composeMiddleware } from '../rpcMethod/net';\nimport { RPCRequestPayload } from '../types';\n\nclass WSProvider extends BaseSocket {\n  get connected() {\n    return this.connection.readyState === this.connection.OPEN;\n  }\n\n  url: string;\n  subscriptions: any;\n  options: any;\n  connection: W3CWebsocket | WebSocket;\n  jsonRpc: JsonRpc;\n\n  // ws: w3cwebsocket;\n  constructor(url: string, options: any = {}) {\n    super(url);\n    if (!isWs(url)) {\n      throw new Error(`${url} is not websocket`);\n    }\n    this.url = url;\n    this.options = options;\n    this.connection = this.createWebsocketProvider(this.url, this.options);\n    this.jsonRpc = new JsonRpc();\n    this.subscriptions = {};\n    this.registerEventListeners();\n    // this.on = this.emitter.on.bind(this);\n  }\n\n  on(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, handler);\n    return this;\n  }\n  onData(handler: any) {\n    this.emitter.on('data', handler);\n    return this;\n  }\n  onError(event: any) {\n    if (event.code === 'ECONNREFUSED') {\n      this.reconnect();\n      return;\n    }\n    super.onError(event);\n  }\n  onClose(closeEvent: any) {\n    if (closeEvent.code !== 1000 || closeEvent.wasClean === false) {\n      this.reconnect();\n      return;\n    }\n    super.onClose();\n  }\n\n  createWebsocketProvider(url: string, options: any = {}) {\n    // tslint:disable-next-line: no-string-literal\n    if (typeof window !== 'undefined' && (<any>window).WebSocket) {\n      // tslint:disable-next-line: no-string-literal\n      return new WebSocket(url, options.protocol);\n    } else {\n      const headers = options.headers || {};\n      const urlObject = new URL(url);\n\n      if (!headers.authorization && urlObject.username && urlObject.password) {\n        const authToken = Buffer.from(`${urlObject.username}:${urlObject.password}`).toString(\n          'base64',\n        );\n        headers.authorization = `Basic ${authToken}`;\n      }\n\n      return new W3CWebsocket(\n        url,\n        options.protocol,\n        undefined,\n        headers,\n        undefined,\n        options.clientConfig,\n      );\n    }\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      this.removeAllSocketListeners();\n      this.connection = this.createWebsocketProvider(this.url, this.options);\n      this.registerEventListeners();\n    }, 5000);\n  }\n  isConnecting() {\n    return this.connection.readyState === this.connection.CONNECTING;\n  }\n\n  send(payload: RPCRequestPayload<object>): Promise<any> {\n    const [tReq, tRes] = this.getMiddleware(payload.method);\n    const reqMiddleware = composeMiddleware(...tReq);\n    const resMiddleware = composeMiddleware(...tRes);\n\n    return new Promise((resolve, reject) => {\n      // TODO: test on Error\n\n      if (this.connected) {\n        try {\n          this.connection.send(reqMiddleware(JSON.stringify(payload)));\n        } catch (error) {\n          // TODO !isConnecting then reconnect?\n          this.removeEventListener(SocketConnection.ERROR);\n          throw error;\n        }\n      }\n      this.emitter.on(SocketConnection.CONNECT, () => {\n        try {\n          this.connection.send(reqMiddleware(JSON.stringify(payload)));\n        } catch (error) {\n          // TODO !isConnecting then reconnect?\n          this.removeEventListener(SocketConnection.ERROR);\n          throw error;\n        }\n      });\n      this.emitter.on(`${payload.id}`, (data) => {\n        resolve(resMiddleware(data));\n        this.removeEventListener(`${payload.id}`);\n      });\n      this.emitter.on(SocketConnection.ERROR, reject);\n    });\n  }\n\n  async subscribe(payload: RPCRequestPayload<any[]>) {\n    const response = await this.send(payload);\n    const responseValidateResult = this.validate(response);\n    if (responseValidateResult instanceof Error) {\n      throw responseValidateResult;\n    }\n    this.subscriptions[response.result] = {\n      id: response.result,\n      subscribeMethod: payload.method,\n      parameters: payload.params,\n      payload,\n    };\n\n    return response.result;\n  }\n\n  async unsubscribe(payload: RPCRequestPayload<any[]>) {\n    const subscriptionId = payload.params[0];\n    if (this.hasSubscription(subscriptionId)) {\n      return this.send(payload).then((response) => {\n        if (response) {\n          this.removeEventListener(this.getSubscriptionEvent(subscriptionId));\n          delete this.subscriptions[subscriptionId];\n        }\n\n        return response;\n      });\n    }\n\n    return Promise.reject(\n      new Error(`Provider error: Subscription with ID ${subscriptionId} does not exist.`),\n    );\n  }\n\n  async clearSubscriptions(unsubscribeMethod: string) {\n    const unsubscribePromises: Array<Promise<any>> = [];\n\n    Object.keys(this.subscriptions).forEach((key) => {\n      this.removeEventListener(key);\n      unsubscribePromises.push(\n        this.unsubscribe(this.jsonRpc.toPayload(unsubscribeMethod, this.subscriptions[key].id)),\n      );\n    });\n\n    const results = await Promise.all(unsubscribePromises);\n    if (results.includes(false)) {\n      throw new Error(`Could not unsubscribe all subscriptions: ${JSON.stringify(results)}`);\n    }\n    return true;\n  }\n\n  registerEventListeners() {\n    this.connection.onmessage = this.onMessage.bind(this);\n    this.connection.onopen = this.onReady.bind(this);\n    this.connection.onopen = this.onConnect.bind(this);\n    this.connection.onclose = this.onClose.bind(this);\n    this.connection.onerror = this.onError.bind(this);\n  }\n\n  onMessage(msg: MessageEvent) {\n    if (msg && msg.data) {\n      let result;\n      let event;\n      try {\n        result = isObject(msg.data) ? msg.data : JSON.parse(msg.data);\n\n        if (isArray(result)) {\n          event = result[0].id;\n        }\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (typeof result.id === 'undefined') {\n          event =\n            this.getSubscriptionEvent(result.params.subscription) || result.params.subscription;\n          // result = result.params;\n        } else {\n          event = result.id;\n        }\n      } catch (error) {\n        throw error;\n      }\n      this.emitter.emit(SocketState.SOCKET_MESSAGE, result);\n      this.emitter.emit(`${event}`, result);\n    } else {\n      throw new Error('provider error');\n    }\n  }\n  async onConnect() {\n    if (!this.subscriptions) {\n      this.subscriptions = {};\n    }\n    const subscriptionKeys = Object.keys(this.subscriptions);\n\n    if (subscriptionKeys.length > 0) {\n      for (const key of subscriptionKeys) {\n        const subscriptionId: any = await this.subscribe(this.subscriptions[key].payload);\n        delete this.subscriptions[subscriptionId];\n        this.subscriptions[key].id = subscriptionId;\n      }\n    }\n\n    this.emitter.emit(SocketState.SOCKET_CONNECT);\n    this.emitter.emit(SocketConnection.CONNECT);\n  }\n  getSubscriptionEvent(subscriptionId: any) {\n    if (this.subscriptions[subscriptionId]) {\n      return subscriptionId;\n    }\n\n    let event;\n    Object.keys(this.subscriptions).forEach((key) => {\n      if (this.subscriptions[key].id === subscriptionId) {\n        event = key;\n      }\n    });\n\n    return event;\n  }\n  hasSubscription(subscriptionId: string) {\n    return typeof this.getSubscriptionEvent(subscriptionId) !== 'undefined';\n  }\n  validate(response: any, payload?: any) {\n    if (isObject(response)) {\n      if (response.error) {\n        if (response.error instanceof Error) {\n          return new Error(`Node error: ${response.error.message}`);\n        }\n\n        return new Error(`Node error: ${JSON.stringify(response.error)}`);\n      }\n\n      if (payload && response.id !== payload.id) {\n        return new Error(\n          `Validation error: Invalid JSON-RPC response ID (request: ${payload.id} / response: ${response.id})`,\n        );\n      }\n\n      if (response.result === undefined) {\n        return new Error('Validation error: Undefined JSON-RPC result');\n      }\n\n      return true;\n    }\n\n    return new Error('Validation error: Response should be of type Object');\n  }\n}\n\nexport { WSProvider };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport mitt from 'mitt';\n\nclass Emitter {\n  handlers?: any = {};\n  emitter: mitt.Emitter;\n  off: (type: string, handler: mitt.Handler) => void;\n  emit: (type: string, event?: any) => void;\n  promise: Promise<{}>;\n  resolve?: any;\n  reject?: any;\n  then?: any;\n  constructor() {\n    this.emitter = mitt(this.handlers);\n    this.off = this.emitter.off.bind(this);\n    this.emit = this.emitter.emit.bind(this);\n    // tslint:disable-next-line: no-empty\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n    this.then = this.promise.then.bind(this.promise);\n  }\n\n  resetHandlers() {\n    // tslint:disable-next-line: forin\n    for (const i in this.handlers) {\n      delete this.handlers[i];\n    }\n  }\n  on(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, handler);\n    return this;\n  }\n  once(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, (e: any) => {\n      handler(e);\n      this.removeEventListener(type);\n    });\n  }\n\n  addEventListener(type: string, handler: mitt.Handler) {\n    this.emitter.on(type, handler);\n  }\n\n  removeEventListener(type?: string, handler?: mitt.Handler) {\n    if (!type) {\n      this.handlers = {};\n      return;\n    }\n    if (!handler) {\n      delete this.handlers[type];\n    } else {\n      return this.emitter.off(type, handler);\n    }\n  }\n  onError(error: any) {\n    this.emitter.on('error', error);\n    this.removeEventListener('*');\n  }\n  onData(data: any) {\n    this.emitter.on('data', data);\n    this.removeEventListener('*');\n  }\n  listenerCount(listenKey: any) {\n    let count = 0;\n    Object.keys(this.handlers).forEach((val) => {\n      if (listenKey === val) {\n        count += 1;\n      }\n    });\n    return count;\n  }\n}\n\nexport { Emitter };\n","/**\n # avalanche-js-network\n\nThis package provides a collection of apis to create messengers (HTTP, WebSocket) to connect to blockchain networks.\n\n## Installation\n\n```\nnpm install avalanche-js-network\n```\n\n## Usage\n\n```javascript\nconst { Messenger, HttpProvider, WSProvider } = require('avalanche-js-network');\nconst { ChainID, ChainType } = require('avalanche-js-utils');\nconst testnetHTTP = 'https://api.s0.b.hmny.io';\nconst testnetWS = 'wss://ws.s0.b.hmny.io';\nconst localHTTP = 'http://localhost:9500/';\nconst localWS = 'http://localhost:9800/';\nconst http = new HttpProvider(testnetHTTP); // for local use localHTTP\nconst ws = new WSProvider(testnetWS); // for local use testnetWS\nconst customHTTPMessenger = new Messenger(http, ChainType.Avalanche, ChainID.HmyTestnet); // for local ChainID.HmyLocal\nconst customWSMessenger = new Messenger(ws, ChainType.Avalanche, ChainID.HmyTestnet); // for local ChainID.HmyLocal\n```\n *\n * @packageDocumentation\n * @module avalanche-network\n */\n\n/**@ignore */\nexport enum RPCMethod {\n  // 1. hmy_getBlockByHash\n  GetBlockByHash = 'hmy_getBlockByHash',\n  // 2. hmy_getBlockByNumber\n  GetBlockByNumber = 'hmy_getBlockByNumber',\n  // 3. hmy_getBlockTransactionCountByHash\n  GetBlockTransactionCountByHash = 'hmy_getBlockTransactionCountByHash',\n  // 4. hmy_getBlockTransactionCountByNumber\n  GetBlockTransactionCountByNumber = 'hmy_getBlockTransactionCountByNumber',\n  // 5. hmy_getCode\n  GetCode = 'hmy_getCode',\n  // 6. hmy_getTransactionByBlockHashAndIndex\n  GetTransactionByBlockHashAndIndex = 'hmy_getTransactionByBlockHashAndIndex',\n  // 7. hmy_getTransactionByBlockNumberAndIndex\n  GetTransactionByBlockNumberAndIndex = 'hmy_getTransactionByBlockNumberAndIndex',\n  // 8. hmy_getTransactionByHash\n  GetTransactionByHash = 'hmy_getTransactionByHash',\n\n  GetTransactionReceipt = 'hmy_getTransactionReceipt',\n\n  GetCXReceiptByHash = 'hmy_getCXReceiptByHash',\n  // 9. hmy_syncing\n  Syncing = 'hmy_syncing',\n  // 10. net_peerCount\n  PeerCount = 'net_peerCount',\n\n  // 11. hmy_getBalance\n  GetBalance = 'hmy_getBalance',\n  // 12. hmy_getStorageAt\n  GetStorageAt = 'hmy_getStorageAt',\n  // 13. hmy_getTransactionCount\n  GetTransactionCount = 'hmy_getTransactionCount',\n  // 14. hmy_sendTransaction\n  SendTransaction = 'hmy_sendTransaction',\n  // 15. hmy_sendRawTransaction\n  SendRawTransaction = 'hmy_sendRawTransaction',\n  // 16. hmy_subscribe\n  Subscribe = 'hmy_subscribe',\n  // 17. hmy_getlogs\n  GetPastLogs = 'hmy_getLogs',\n  // 18. hmy_getWork\n  GetWork = 'hmy_getWork',\n  // 19. hmy_submitWork\n  // SubmitWork = 'hmy_submitWork',\n  // 20. hmy_getProof\n  GetProof = 'hmy_getProof',\n  // 21, hmy_getFilterChanges\n  GetFilterChanges = 'hmy_getFilterChanges',\n  // 22. hmy_newPendingTransactionFilter\n  NewPendingTransactionFilter = 'hmy_newPendingTransactionFilter',\n  // 23. hmy_newBlockFilter\n  NewBlockFilter = 'hmy_newBlockFilter',\n  // 24. hmy_newFilter\n  NewFilter = 'hmy_newFilter',\n  // 25. hmy_call\n  Call = 'hmy_call',\n  // 26. hmy_estimateGas\n  EstimateGas = 'hmy_estimateGas',\n  // 27. hmy_gasPrice\n  GasPrice = 'hmy_gasPrice',\n  // 28. hmy_blockNumber\n  BlockNumber = 'hmy_blockNumber',\n  // 29. hmy_unsubscribe\n  UnSubscribe = 'hmy_unsubscribe',\n  // 30. net_version\n  NetVersion = 'net_version',\n  // 31. hmy_protocolVersion\n  ProtocolVersion = 'hmy_protocolVersion',\n  // 32. hmy_getShardingStructure\n  GetShardingStructure = 'hmy_getShardingStructure',\n  // 33. hmy_sendRawStakingTransaction\n  SendRawStakingTransaction = 'hmy_sendRawStakingTransaction',\n  // 34. hmy_getAccountNonce\n  GetAccountNonce = 'hmy_getAccountNonce',\n}\n\n/**@ignore */\nexport enum RPCErrorCode {\n  // Standard JSON-RPC 2.0 errors\n  // RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).\n  // It should not be used for application-layer errors.\n  RPC_INVALID_REQUEST = -32600,\n  // RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).\n  // It should not be used for application-layer errors.\n  RPC_METHOD_NOT_FOUND = -32601,\n  RPC_INVALID_PARAMS = -32602,\n  // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind\n  // (for example datadir corruption).\n  RPC_INTERNAL_ERROR = -32603,\n  RPC_PARSE_ERROR = -32700,\n\n  // General application defined errors\n  RPC_MISC_ERROR = -1, // std::exception thrown in command handling\n  RPC_TYPE_ERROR = -3, // Unexpected type was passed as parameter\n  RPC_INVALID_ADDRESS_OR_KEY = -5, // Invalid address or key\n  RPC_INVALID_PARAMETER = -8, // Invalid, missing or duplicate parameter\n  RPC_DATABASE_ERROR = -20, // Database error\n  RPC_DESERIALIZATION_ERROR = -22, // Error parsing or validating structure in raw format\n  RPC_VERIFY_ERROR = -25, // General error during transaction or block submission\n  RPC_VERIFY_REJECTED = -26, // Transaction or block was rejected by network rules\n  RPC_IN_WARMUP = -28, // Client still warming up\n  RPC_METHOD_DEPRECATED = -32, // RPC method is deprecated\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { RPCResponseBody } from '../types';\nimport { isObject } from 'avalanche-js-utils';\n/**\n * @class ResponseMiddleware\n * @description Response middleware of RPC\n * @param  {Object}  ResponseBody - response from rpc\n * @return {ResponseMiddleware} response middleware instance\n */\nclass ResponseMiddleware {\n  result: any;\n  error: any;\n  raw: any;\n  responseType: string;\n  constructor(ResponseBody: RPCResponseBody<any, any>) {\n    this.result = ResponseBody.result;\n    this.error = ResponseBody.error;\n    this.raw = ResponseBody;\n    this.responseType = this.getResponseType();\n  }\n\n  get getResult() {\n    return isObject(this.result) ? { ...this.result, responseType: 'result' } : this.result;\n  }\n\n  get getError() {\n    return isObject(this.error) ? { ...this.error, responseType: 'error' } : this.error;\n  }\n\n  get getRaw() {\n    return { ...this.raw, responseType: 'raw' };\n  }\n\n  getResponseType(): string {\n    if (this.error) {\n      return 'error';\n    } else if (this.result || (this.result === null && this.result !== undefined)) {\n      return 'result';\n    } else {\n      return 'raw';\n    }\n  }\n\n  isError(): boolean {\n    return this.responseType === 'error';\n  }\n  isResult(): boolean {\n    return this.responseType === 'result';\n  }\n  isRaw(): boolean {\n    return this.responseType === 'raw';\n  }\n}\nexport { ResponseMiddleware };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { AvalancheCore, ChainType, isString, ChainID, defaultConfig } from 'avalanche-js-utils';\nimport { JsonRpc } from '../rpcMethod/builder';\nimport { ResponseMiddleware } from './responseMiddleware';\nimport { HttpProvider } from '../providers/http';\nimport { WSProvider } from '../providers/ws';\n// import { getResultForData } from '../util';\nimport { RPCMethod } from '../rpcMethod/rpc';\nimport { SubscribeReturns, ShardingItem } from '../types';\n\n/** @hidden */\nexport interface ShardingProvider {\n  current: boolean;\n  shardID: number;\n  http: string;\n  ws: string;\n}\n\n/**\n * ## How to Create a Massage\n * @example\n * ```\n * const { HttpProvider, Messenger } = require('avalanche-js-network');\n * const { ChainType, ChainID } = require('avalanche-js-utils');\n *\n * // create a custom messenger\n * const customMessenger = new Messenger(\n *   new HttpProvider('http://localhost:9500'),\n *   ChainType.Avalanche, // if you are connected to Avalanche's blockchain\n *   ChainID.HmyLocal, // check if the chainId is correct\n * )\n * ```\n */\nclass Messenger extends AvalancheCore {\n  provider: HttpProvider | WSProvider;\n  config?: object;\n  // tslint:disable-next-line: variable-name\n  Network_ID: string = 'Default';\n  shardProviders: Map<number, ShardingProvider>;\n\n  JsonRpc: JsonRpc;\n  defaultShardID?: number;\n\n  constructor(\n    provider: HttpProvider | WSProvider,\n    chainType: ChainType = defaultConfig.Default.Chain_Type,\n    chainId: ChainID = defaultConfig.Default.Chain_ID,\n    config: object = defaultConfig,\n  ) {\n    super(chainType, chainId);\n\n    /**\n     * @var {Provider} provider\n     * @memberof Messenger.prototype\n     * @description Provider instance\n     */\n    this.provider = provider;\n\n    /**\n     * @var {Object} config\n     * @memberof Messenger.prototype\n     * @description Messenger config\n     */\n    this.config = config;\n    /**\n     * @var {Number} Network_ID\n     * @memberof Messenger.prototype\n     * @description Network ID for current provider\n     */\n\n    /**\n     * @var {JsonRpc} JsonRpc\n     * @memberof Messenger.prototype\n     * @description JsonRpc instance\n     */\n    this.JsonRpc = new JsonRpc();\n\n    // set Network ID\n    this.setNetworkID(defaultConfig.Default.Network_ID);\n\n    // set shardingProviders\n\n    this.shardProviders = new Map();\n    // this.setShardingProviders();\n  }\n\n  /**\n   * @example\n   * ```\n   * customMessenger.currentShard\n   * ```\n   */\n  get currentShard(): number {\n    return this.getCurrentShardID() || this.defaultShardID || 0;\n  }\n\n  /**\n   * @example\n   * ```\n   * customMessenger.shardCount\n   * ```\n   */\n  get shardCount(): number {\n    return this.shardProviders.size;\n  }\n\n  /**\n   * @function send\n   * @memberof Messenger.prototype\n   * @param  {String} method - RPC method\n   * @param  {Object} params - RPC method params\n   * @return {Object} RPC result\n   */\n  send = async (\n    method: RPCMethod | string,\n    params?: string | any[] | undefined,\n    rpcPrefix?: string,\n    shardID: number = this.currentShard,\n  ) => {\n    this.providerCheck();\n    let rpcMethod = method;\n    if (rpcPrefix && isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, rpcPrefix);\n    } else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, this.chainPrefix);\n    }\n    try {\n      const payload = this.JsonRpc.toPayload(rpcMethod, params);\n      const provider = this.getShardProvider(shardID);\n      this.setResMiddleware(\n        (data: any) => {\n          if (!(data instanceof ResponseMiddleware)) {\n            return new ResponseMiddleware(data);\n          } else {\n            return data;\n          }\n        },\n        '*',\n        provider,\n      );\n\n      const result = await provider.send(payload);\n      return result;\n      // return getResultForData(result); // getResultForData(result)\n    } catch (e) {\n      throw new Error(e);\n    }\n  };\n\n  /**\n   * @function setProvider\n   * @memberof Messenger\n   * @description provider setter\n   * @param  {Provider} provider - provider instance\n   */\n  setProvider(provider: HttpProvider | WSProvider) {\n    this.provider = provider;\n  }\n\n  /**\n   * @function providerCheck\n   * @memberof Messenger\n   * @description provider checker\n   * @return {Error|null} provider validator\n   */\n  providerCheck() {\n    if (!this.provider) {\n      throw new Error('provider is not found');\n    }\n  }\n\n  /**\n   * @function setReqMiddleware\n   * @description set request middleware\n   * @memberof Messenger\n   * @param  {any} middleware - middle ware for req\n   * @param  {String} method  - method name\n   * @hidden\n   */\n  setReqMiddleware(middleware: any, method = '*', provider: HttpProvider | WSProvider) {\n    provider.middlewares.request.use(middleware, method);\n  }\n\n  /**\n   * @function setResMiddleware\n   * @description set response middleware\n   * @memberof Messenger\n   * @param  {any} middleware - middle ware for req\n   * @param  {String} method  - method name\n   * @hidden\n   */\n  setResMiddleware(middleware: any, method = '*', provider: HttpProvider | WSProvider) {\n    provider.middlewares.response.use(middleware, method);\n  }\n\n  /**\n   * @function setNetworkID\n   * @description set network id\n   * @memberof Messenger\n   * @param  {String} id network id string\n   */\n  setNetworkID(id: string) {\n    this.Network_ID = id;\n  }\n\n  setRPCPrefix(method: RPCMethod | string, prefix: string): string {\n    const stringArray: string[] = method.split('_');\n    if (stringArray.length !== 2) {\n      throw new Error(`could not set prefix with ${method}`);\n    }\n    stringArray[0] = prefix;\n    return stringArray.join('_');\n  }\n\n  subscribe = async (\n    method: RPCMethod | string,\n    params?: string | any[] | undefined,\n    returnType: SubscribeReturns = SubscribeReturns.all,\n    rpcPrefix: string = this.chainPrefix,\n    shardID: number = this.currentShard,\n  ) => {\n    let rpcMethod = method;\n    if (rpcPrefix && isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, rpcPrefix);\n    } else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, this.chainPrefix);\n    }\n    let id: any = null;\n    const provider = this.getShardProvider(shardID);\n    if (provider instanceof WSProvider) {\n      const reProvider = provider;\n\n      try {\n        const payload = this.JsonRpc.toPayload(rpcMethod, params);\n        id = await reProvider.subscribe(payload);\n        reProvider.on(id, (result: any) => {\n          reProvider.emitter.emit('data', result);\n        });\n        reProvider.once('error', (error) => {\n          reProvider.removeEventListener(id);\n          reProvider.emitter.emit('error', error);\n          reProvider.removeEventListener('*');\n        });\n      } catch (error) {\n        reProvider.emitter.emit('error', error);\n        reProvider.removeEventListener('*');\n      }\n      if (returnType === SubscribeReturns.all) {\n        return [reProvider, id];\n      } else if (returnType === SubscribeReturns.method) {\n        return reProvider;\n      } else if (returnType === SubscribeReturns.id) {\n        return id;\n      } else {\n        throw new Error('Invalid returns');\n      }\n    } else {\n      throw new Error('HttpProvider does not support this');\n    }\n  };\n\n  unsubscribe = async (\n    method: RPCMethod | string,\n    params?: string | any[] | undefined,\n    rpcPrefix?: string,\n    shardID: number = this.currentShard,\n  ) => {\n    let rpcMethod = method;\n    if (rpcPrefix && isString(rpcPrefix) && rpcPrefix !== this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, rpcPrefix);\n    } else if (!rpcPrefix || rpcPrefix === this.chainPrefix) {\n      rpcMethod = this.setRPCPrefix(method, this.chainPrefix);\n    }\n    const provider = this.getShardProvider(shardID);\n    if (provider instanceof WSProvider) {\n      const reProvider = this.provider;\n      try {\n        const payload = this.JsonRpc.toPayload(rpcMethod, params);\n        const response = await reProvider.unsubscribe(payload);\n        return response;\n      } catch (error) {\n        throw error;\n      }\n    } else {\n      throw new Error('HttpProvider does not support this');\n    }\n  };\n\n  async setShardingProviders() {\n    if (this.chainPrefix !== ChainType.Avalanche) {\n      return;\n    }\n    try {\n      const response = await this.send(RPCMethod.GetShardingStructure, [], this.chainPrefix);\n\n      if (response.result) {\n        const shardingStructures: ShardingItem[] = response.result;\n        for (const shard of shardingStructures) {\n          const shardID =\n            typeof shard.shardID === 'string' ? Number.parseInt(shard.shardID, 10) : shard.shardID;\n          this.shardProviders.set(shardID, {\n            current: shard.current,\n            shardID,\n            http: shard.http,\n            ws: shard.ws,\n          });\n        }\n      }\n    } catch (error) {\n      return;\n    }\n  }\n\n  /**\n   * @example\n   * ```\n   * hmy.messenger.getShardProvider()\n   * ```\n   */\n  getShardProvider(shardID: number): HttpProvider | WSProvider {\n    const provider = this.shardProviders.get(shardID);\n    if (provider) {\n      return this.provider instanceof HttpProvider\n        ? new HttpProvider(provider.http)\n        : new WSProvider(provider.ws);\n    }\n    return this.provider;\n  }\n\n  /**\n   * @example\n   * ```\n   * hmy.messenger.getCurrentShardID()\n   * ```\n   */\n\n  getCurrentShardID() {\n    for (const shard of this.shardProviders) {\n      if (\n        shard[1].current === true ||\n        shard[1].http === this.provider.url ||\n        shard[1].ws === this.provider.url\n      ) {\n        return shard[1].shardID;\n      }\n    }\n  }\n  setDefaultShardID(shardID: number) {\n    this.defaultShardID = shardID;\n  }\n}\nexport { Messenger };\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { isHex, hexToNumber } from 'avalanche-js-utils';\nimport { Emitter } from '../providers/emitter';\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator: number, currentValue: number) => accumulator + currentValue;\nconst blockTrackerEvents = ['sync', 'latest'];\n\nexport class BaseBlockTracker extends Emitter {\n  // tslint:disable-next-line: variable-name\n  _blockResetDuration?: number;\n  // tslint:disable-next-line: variable-name\n  _blockResetTimeout: any;\n  // tslint:disable-next-line: variable-name\n  _currentBlock: any;\n  // tslint:disable-next-line: variable-name\n  _isRunning: boolean;\n  constructor(\n    opts: any = {\n      blockResetDuration: undefined,\n      retryTimeout: undefined,\n      keepEventLoopActive: undefined,\n      setSkipCacheFlag: false,\n    },\n  ) {\n    super();\n    // config\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n    // state\n    // tslint:disable-next-line: no-unused-expression\n    this._blockResetTimeout;\n    this._currentBlock = null;\n    this._isRunning = false;\n    // bind functions for internal use\n    // this._onNewListener = this._onNewListener.bind(this);\n    // this._onRemoveListener = this._onRemoveListener.bind(this);\n    // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n    // listen for handler changes\n    // this._setupInternalEvents();\n    this._maybeStart();\n  }\n\n  isRunning() {\n    return this._isRunning;\n  }\n\n  getCurrentBlock() {\n    return this._currentBlock;\n  }\n\n  async getLatestBlock() {\n    // return if available\n    if (this._currentBlock) {\n      return this._currentBlock;\n    }\n    // wait for a new latest block\n    const latestBlock = await new Promise((resolve) => this.once('latest', resolve));\n    // return newly set current block\n    return latestBlock;\n  }\n\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners(eventName: string) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      super.removeEventListener(eventName);\n    } else {\n      super.removeEventListener('*');\n    }\n    // re-add internal events\n    this._setupInternalEvents();\n    // trigger stop check just in case\n    this._onRemoveListener('*');\n  }\n\n  //\n  // to be implemented in subclass\n  //\n\n  _start() {\n    // default behavior is noop\n  }\n\n  _end() {\n    // default behavior is noop\n  }\n\n  //\n  // private\n  //\n\n  _setupInternalEvents() {\n    // first remove listeners for idempotence\n    this.removeEventListener('newListener', this._onNewListener);\n    this.removeEventListener('removeListener', this._onRemoveListener);\n    // then add them\n\n    this.on('newListener', this._onNewListener);\n    this.on('removeListener', this._onRemoveListener);\n  }\n\n  _onNewListener(eventName: string, handler?: mitt.Handler) {\n    // `newListener` is called *before* the listener is added\n    if (!blockTrackerEvents.includes(eventName)) {\n      return;\n    }\n\n    this._maybeStart();\n  }\n\n  _onRemoveListener(eventName: string, handler?: mitt.Handler) {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n\n  _maybeStart() {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout();\n    this._start();\n  }\n\n  _maybeEnd() {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n    this._setupBlockResetTimeout();\n    this._end();\n  }\n\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents\n      .map((eventName) => this.listenerCount(eventName))\n      .reduce(calculateSum);\n  }\n\n  _newPotentialLatest(newBlock: string) {\n    const currentBlock = this._currentBlock;\n    // only update if blok number is higher\n    if (\n      currentBlock &&\n      isHex(currentBlock) &&\n      isHex(newBlock) &&\n      hexToNumber(newBlock) <= hexToNumber(currentBlock)\n    ) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n\n  _setCurrentBlock(newBlock: string) {\n    const oldBlock = this._currentBlock;\n    this._currentBlock = newBlock;\n    this.emit('latest', newBlock);\n    this.emit('sync', { oldBlock, newBlock });\n  }\n\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout();\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  _cancelBlockResetTimeout() {\n    clearTimeout(this._blockResetTimeout);\n  }\n\n  _resetCurrentBlock() {\n    this._currentBlock = null;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { BaseBlockTracker } from './baseTracker';\nimport { Messenger } from '../messenger/messenger';\nimport { RPCMethod } from '../rpcMethod/rpc';\n\nconst sec = 1000;\n\nexport function timeout(duration: number, unref: any) {\n  return new Promise((resolve) => {\n    const timoutRef: any = setTimeout(resolve, duration);\n    // don't keep process open\n    if (timoutRef.unref && unref) {\n      timoutRef.unref();\n    }\n  });\n}\nexport class PollingBlockTracker extends BaseBlockTracker {\n  messenger: Messenger;\n  // tslint:disable-next-line: variable-name\n  _pollingInterval: number;\n  // tslint:disable-next-line: variable-name\n  _retryTimeout: number;\n  // tslint:disable-next-line: variable-name\n  _keepEventLoopActive: boolean;\n  // tslint:disable-next-line: variable-name\n  _setSkipCacheFlag: boolean;\n  constructor(\n    messenger: Messenger,\n    opts = {\n      pollingInterval: undefined,\n      retryTimeout: undefined,\n      keepEventLoopActive: false,\n      setSkipCacheFlag: false,\n    },\n  ) {\n    // parse + validate args\n    if (!messenger) {\n      throw new Error('PollingBlockTracker - no provider specified.');\n    }\n\n    const pollingInterval: number = opts.pollingInterval || 20 * sec;\n    const retryTimeout: number = opts.retryTimeout || pollingInterval / 10;\n    const keepEventLoopActive: boolean =\n      opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true;\n    const setSkipCacheFlag = opts.setSkipCacheFlag || false;\n    // BaseBlockTracker constructor\n    super({\n      blockResetDuration: pollingInterval,\n      retryTimeout,\n      keepEventLoopActive,\n      setSkipCacheFlag,\n    });\n    // config\n    this.messenger = messenger;\n    this._pollingInterval = pollingInterval;\n    this._retryTimeout = retryTimeout;\n    this._keepEventLoopActive = keepEventLoopActive;\n    this._setSkipCacheFlag = setSkipCacheFlag;\n  }\n\n  //\n  // public\n  //\n\n  // trigger block polling\n  async checkForLatestBlock() {\n    await this._updateLatestBlock();\n    const result = await this.getLatestBlock();\n    return result;\n  }\n\n  //\n  // private\n  //\n\n  _start() {\n    this._performSync().catch((err) => this.emit('error', err));\n  }\n\n  async _performSync() {\n    while (this._isRunning) {\n      try {\n        await this._updateLatestBlock();\n        await timeout(this._pollingInterval, !this._keepEventLoopActive);\n      } catch (err) {\n        const newErr = new Error(\n          `PollingBlockTracker - encountered an error while attempting to update latest block:\\n${err.stack}`,\n        );\n        try {\n          this.emit('error', newErr);\n        } catch (emitErr) {\n          console.error(newErr);\n        }\n        await timeout(this._retryTimeout, !this._keepEventLoopActive);\n      }\n    }\n  }\n\n  async _updateLatestBlock() {\n    // fetch + set latest block\n    const latestBlock = await this._fetchLatestBlock();\n    this._newPotentialLatest(latestBlock);\n  }\n\n  async _fetchLatestBlock() {\n    try {\n      const result = await this.messenger.send(RPCMethod.BlockNumber, []);\n      if (result.isError()) {\n        throw result.message;\n      } else if (result.isResult()) {\n        return result.result;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { WSProvider } from '../providers/ws';\nimport { BaseBlockTracker } from './baseTracker';\nimport { RPCMethod } from '../rpcMethod/rpc';\n\nexport class SubscribeBlockTracker extends BaseBlockTracker {\n  messenger: Messenger;\n  subscriptionId: any;\n  // tslint:disable-next-line: variable-name\n\n  constructor(messenger: Messenger, opts = {}) {\n    // parse + validate args\n    if (!messenger) {\n      throw new Error('SubscribeBlockTracker - no provider specified.');\n    }\n    if (!(messenger.provider instanceof WSProvider)) {\n      throw new Error('This provider not supported');\n    }\n    // BaseBlockTracker constructor\n    super(opts);\n    // config\n    this.messenger = messenger;\n    this.subscriptionId = null;\n  }\n\n  async checkForLatestBlock() {\n    const result = await this.getLatestBlock();\n    return result;\n  }\n\n  async _start() {\n    try {\n      const blockNumber = await this.messenger.send(RPCMethod.BlockNumber, []);\n\n      if (blockNumber.isError()) {\n        throw blockNumber.message;\n      } else if (blockNumber.isResult()) {\n        const subs = await this.messenger.subscribe(RPCMethod.Subscribe, ['newHeads']);\n        this.subscriptionId = subs;\n        subs[0].onData(this._handleSubData);\n\n        this._newPotentialLatest(blockNumber);\n      }\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  async _end() {\n    if (this.subscriptionId != null) {\n      this.messenger.unsubscribe(RPCMethod.UnSubscribe, [this.subscriptionId]);\n      delete this.subscriptionId;\n    }\n  }\n\n  _handleSubData(data: any) {\n    if (\n      // data.method === 'eth_subscription' &&\n      data.params.subscription === this.subscriptionId\n    ) {\n      this._newPotentialLatest(data.params.result.number);\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { RPCMethod } from '../rpcMethod/rpc';\nimport { WSProvider } from '../providers/ws';\nimport { RPCRequestPayload } from '../types';\n\nexport class SubscriptionMethod extends WSProvider {\n  param: any;\n  options: any;\n  shardID: number;\n  messenger: Messenger;\n\n  subscriptionId: any = null;\n  constructor(param: any, options: any, messenger: Messenger, shardID: number = 0) {\n    super(shardID !== 0 ? messenger.getShardProvider(shardID).url : messenger.provider.url);\n    this.shardID = shardID;\n    this.param = param;\n    this.options = options;\n    this.messenger = messenger;\n  }\n\n  constructPayload(method: string, param: any, options?: any): RPCRequestPayload<any> {\n    let rpcMethod = method;\n    const payload: any = [];\n    payload.push(param);\n    if (options) {\n      payload.push(options);\n    }\n    rpcMethod = this.messenger.setRPCPrefix(method, this.messenger.chainPrefix);\n    return this.jsonRpc.toPayload(rpcMethod, payload);\n  }\n\n  async start() {\n    const subscribePayload = this.constructPayload(RPCMethod.Subscribe, this.param, this.options);\n    try {\n      const id = await super.subscribe(subscribePayload);\n      this.subscriptionId = id;\n      this.on(id, (result: any) => {\n        const output = this.onNewSubscriptionItem(result);\n\n        this.emitter.emit('data', output);\n      });\n      this.once('error', (error) => {\n        this.removeEventListener(id);\n        this.emitter.emit('error', error);\n        this.removeEventListener('*');\n      });\n    } catch (error) {\n      this.emitter.emit('error', error);\n      this.removeEventListener('*');\n    }\n    return this;\n  }\n  unsubscribe() {\n    const unsubscribePayload = this.constructPayload(RPCMethod.UnSubscribe, this.subscriptionId);\n    return super.unsubscribe(unsubscribePayload);\n  }\n  onNewSubscriptionItem(subscriptionItem: any) {\n    return subscriptionItem;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { SubscriptionMethod } from './Subscription';\nimport { RPCMethod } from '../rpcMethod/rpc';\n\nexport class LogSub extends SubscriptionMethod {\n  constructor(options: any, messenger: Messenger, shardID: number = 0) {\n    super('logs', options, messenger, shardID);\n    this.preprocess();\n  }\n\n  async preprocess() {\n    if (\n      (this.options.fromBlock && this.options.fromBlock !== 'latest') ||\n      this.options.fromBlock === 0 ||\n      this.options.fromBlock === '0x'\n    ) {\n      try {\n        const getPastLogs = await this.messenger.send(\n          RPCMethod.GetPastLogs,\n          [...this.options],\n          this.messenger.chainType,\n          this.shardID,\n        );\n\n        if (getPastLogs.isError()) {\n          this.emitter.emit('error', getPastLogs.error.message);\n        } else {\n          const logs = getPastLogs.result;\n          logs.forEach((log: any) => {\n            const formattedLog = this.onNewSubscriptionItem(log);\n            this.emitter.emit('data', formattedLog);\n          });\n        }\n        delete this.options.fromBlock;\n        // const sub = this.start();\n        return this.start();\n      } catch (error) {\n        this.emitter.emit('error', error);\n        throw error;\n      }\n    }\n    return this.start();\n  }\n\n  onNewSubscriptionItem(subscriptionItem: any) {\n    // todo log formatter\n    const log = subscriptionItem;\n\n    if (log.removed) {\n      this.emitter.emit('changed', log);\n    }\n\n    return log;\n  }\n  // todo formatter\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { SubscriptionMethod } from './Subscription';\n\n/**\n * ### Description:\n * Subscribes to incoming block headers. This can be used as timer to check for changes on the blockchain.\n */\nexport class NewHeaders extends SubscriptionMethod {\n  constructor(messenger: Messenger, shardID: number = 0) {\n    super('newHeads', undefined, messenger, shardID);\n    this.start();\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { SubscriptionMethod } from './Subscription';\n\n/**\n * ### Description:\n * Subscribes to incoming pending transactions\n */\nexport class NewPendingTransactions extends SubscriptionMethod {\n  constructor(messenger: Messenger, shardID: number = 0) {\n    super('newPendingTransactions', undefined, messenger, shardID);\n    this.start();\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { Messenger } from '../messenger/messenger';\nimport { SubscriptionMethod } from './Subscription';\n\nexport class Syncing extends SubscriptionMethod {\n  isSyncing: boolean | null;\n  constructor(messenger: Messenger, shardID: number = 0) {\n    super('syncing', undefined, messenger, shardID);\n    this.isSyncing = null;\n    this.start();\n  }\n\n  onNewSubscriptionItem(subscriptionItem: any) {\n    const isSyncing = subscriptionItem.params.result.syncing;\n\n    if (this.isSyncing === null) {\n      this.isSyncing = isSyncing;\n      this.emitter.emit('changed', this.isSyncing);\n    }\n\n    if (this.isSyncing === true && isSyncing === false) {\n      this.isSyncing = isSyncing;\n      this.emitter.emit('changed', this.isSyncing);\n    }\n\n    if (this.isSyncing === false && isSyncing === true) {\n      this.isSyncing = isSyncing;\n      this.emitter.emit('changed', this.isSyncing);\n    }\n    // todo formatter\n    return subscriptionItem;\n  }\n}\n","/**\n * @packageDocumentation\n * @module avalanche-network\n * @hidden\n */\n\nimport { ResponseMiddleware } from './messenger/responseMiddleware';\n\n/**\n * @function getResultForData\n * @description get result for data by default\n * @param  {any} data - object get from provider\n * @return {any} data result or data\n */\nexport function getResultForData(data: any): any {\n  if (data.result) {\n    return data.getResult;\n  }\n  if (data.error) {\n    return data.getError;\n  }\n  return data.getRaw;\n}\n\nexport function getRawForData(data: any): any {\n  return data.getRaw;\n}\n\nexport function onResponse(response: ResponseMiddleware) {\n  if (response.responseType === 'result') {\n    return response.getResult;\n  } else if (response.responseType === 'error') {\n    return response.getError;\n  } else {\n    return response.raw;\n  }\n}\n"],"names":["MiddlewareType","SubscribeReturns","SocketConnection","SocketState","EmittType","BaseProvider","url","reqMiddleware","resMiddleware","Map","request","use","fn","match","_this","pushMiddleware","REQ","response","RES","set","type","Error","current","this","get","getMiddleware","method","requests","responses","entries","key","transformers","push","RegExp","test","BaseSocket","isWs","emitter","mitt","handlers","resetHandlers","i","once","handler","on","removeEventListener","addEventListener","off","reset","removeAllSocketListeners","SOCKET_MESSAGE","SOCKET_READY","SOCKET_CLOSE","SOCKET_ERROR","SOCKET_CONNECT","onReady","event","emit","READY","onError","error","ERROR","onClose","CLOSE","fetchRPC","requestHandler","headers","fetch","options","cache","mode","redirect","referrer","body","JSON","stringify","payload","responseHandler","json","then","req","DEFAULT_HEADERS","_fetch","fetchPromise","timeout","abortFn","abortPromise","Promise","resolve","reject","abortablePromise","race","setTimeout","performRPC","fetcher","composeMiddleware","fns","length","arg","reduce","a","b","ProviderType","defaultOptions","user","password","HttpProvider","send","callback","requestFunc","sendServer","endpoint","tRes","obj","_this2","optionsHandler","endpointHandler","payloadHandler","data","callbackHandler","AUTH_TOKEN","Buffer","from","toString","Authorization","cb","subscribe","unsubscribe","JsonRpc","params","messageId","sendParams","undefined","jsonrpc","id","WSProvider","connection","createWebsocketProvider","jsonRpc","subscriptions","registerEventListeners","onData","code","reconnect","closeEvent","wasClean","window","WebSocket","protocol","urlObject","URL","authorization","username","authToken","W3CWebsocket","clientConfig","isConnecting","readyState","CONNECTING","_this3","connected","CONNECT","responseValidateResult","validate","result","subscribeMethod","parameters","hasSubscription","subscriptionId","_this4","getSubscriptionEvent","clearSubscriptions","unsubscribeMethod","unsubscribePromises","Object","keys","forEach","_this5","toPayload","all","results","includes","onmessage","onMessage","bind","onopen","onConnect","onclose","onerror","msg","isObject","parse","isArray","subscription","subscriptionKeys","_this6","message","OPEN","Emitter","promise","e","listenerCount","listenKey","count","val","RPCMethod","RPCErrorCode","Provider","provider","onInitSetProvider","providerType","getType","getProvider","providerUrl","isHttp","defaultConfig","Default","Chain_URL","http","ws","ResponseMiddleware","ResponseBody","raw","responseType","getResponseType","isError","isResult","isRaw","Messenger","chainType","chainId","config","Chain_Type","Chain_ID","rpcPrefix","shardID","currentShard","providerCheck","rpcMethod","isString","chainPrefix","setRPCPrefix","getShardProvider","setResMiddleware","returnType","reProvider","setNetworkID","Network_ID","shardProviders","setProvider","setReqMiddleware","middleware","middlewares","prefix","stringArray","split","join","setShardingProviders","ChainType","Avalanche","GetShardingStructure","shard","Number","parseInt","getCurrentShardID","setDefaultShardID","defaultShardID","size","AvalancheCore","calculateSum","accumulator","currentValue","blockTrackerEvents","BaseBlockTracker","opts","blockResetDuration","retryTimeout","keepEventLoopActive","setSkipCacheFlag","_blockResetDuration","_currentBlock","_isRunning","_maybeStart","isRunning","getCurrentBlock","getLatestBlock","removeAllListeners","eventName","_setupInternalEvents","_onRemoveListener","_start","_end","_onNewListener","_getBlockTrackerEventCount","_maybeEnd","_cancelBlockResetTimeout","_setupBlockResetTimeout","map","_newPotentialLatest","newBlock","currentBlock","isHex","hexToNumber","_setCurrentBlock","oldBlock","_blockResetTimeout","_resetCurrentBlock","unref","clearTimeout","duration","timoutRef","PollingBlockTracker","messenger","pollingInterval","_pollingInterval","_retryTimeout","_keepEventLoopActive","_setSkipCacheFlag","checkForLatestBlock","_updateLatestBlock","_performSync","err","newErr","_context2","stack","emitErr","console","_fetchLatestBlock","BlockNumber","SubscribeBlockTracker","blockNumber","Subscribe","subs","_handleSubData","UnSubscribe","number","SubscriptionMethod","param","constructPayload","start","subscribePayload","output","onNewSubscriptionItem","unsubscribePayload","subscriptionItem","LogSub","preprocess","fromBlock","GetPastLogs","getPastLogs","log","formattedLog","removed","NewHeaders","NewPendingTransactions","Syncing","isSyncing","syncing","getRaw","getResult","getError"],"mappings":"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"}